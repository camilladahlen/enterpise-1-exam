DOCUMENTATION ON ENDPOINTS AND POSTMAN

1.	Logging in

To log in via postman you have to use the POST method and write the path localhost:8080/api/authenticate and write in the body with raw -> JSON

Example:

{
“email”:”admin@admin.com”,
“password”:”pirate”
}

This is the admin-user that is already in the database and you are now allowed to access the end-points you have the right permissions to access.

/api/authenticate uses the LogInInfo data class

2.	Register new user

Follow the same procedure as logging in except change the path from /login -> /register. You can now log in with this user.

3.	Accessing endpoints

Class name: ShelterManagementController

To access /api/shelter/** you must have authority ADMIN or USER.

-	GET /all returns a list of objects in the responsebody of all the animals in the database.

-	GET /{animal_id} return the jobject of the animal you requested if the id is in the database. Here you have to type in the id/number in the url (example: /api/shelter/1) and if the object exists it will list it out.

-	POST /register returns the object you register in the body if done correctly. Here you have to write in the body -> raw -> json
     Example:
     {
     “name”:”yourname”
     }

It uses a data class object I called AnimalRegisterDataInfo with these fields: name, type, breed, age, health

You can choose to post value to how many fields you like, if you don’t pass in the value the value will be null, and id is autogenerated.

-	PUT /update returns the object you updated if done correctly.
     To update an animal you have to pass in the id of the animal (if it exists in the database) and the rest of the fields are optional if you dont want to pass null as a value. This method uses the data class AnimalUpdateDataInfo in the requestbody.

-	DELETE /delete/{animal_id} gets the id from the pathvariable in the url and returns a string that just says deleted. You have to pass in the id/number you want to delete like this : /api/shelter/delete/1.

The ShelterManagementController Autowired the serviceclass AnimalService, and that class autowires the AnimalRepo interface.

The RegisterAnimal and UpdateAnimal both uses the save() method from the repo to update the database.

Class name: UserController

-	POST /register is permitted by all. I used the data class NewUserinfo to get the data from the body. The fields are name and password and the id gets autogenerated, and the password gets encrypted.

-	GET /username has USER and ADMIN authority and responds in the body with the logged in users username. It gets the username from security.principal.

-	GET /{username} has USER and ADMIN authority and respons with the user that is logged in and its info, if the username in the Pathvariable-parameter is the same as the logged in user.
     Example: /api/user/admin@admin.com
     The userservice uses the getUserByUsername method.

If it is not the same it responds with an Exception.

-	GET /all has only admin authority and responds with getAllUsers that prints the list of users from the database.

-	POST /authority/register only has ADMIN authority and takes in a AuthorityEntity in the body. Example:

{
“authorityName”:”USER_WRITE”
}

Responds with the object and 201 created.

-	POST /authority/add has ADMIN authority and adds authority to a user. Takes in the data class AuthorityToUserinfo in the body.
     Example:
     {
     “email”:”user@user.com”,
     “authorityname”:”USER_WRITE”
     }

Responds with 201 created.

That’s all the endpoints for the controllers.

OVERVIEW

One thing I struggled with for some reason I still don’t know, is that I could not set the authFilter.setFilerProcessesUrl to “/api/authenticate/login, because if I did I got 403 on all the other endpoints. I got a cookie and logged in successfully, but the application would not let in with either authority.
It did work when I put it to /api/login or /api/authenticate as it is per now.

Another thing I would like to point out is that I could have made the application so that the different authorities had different roles. For example that USER could have had the role as USER_WRITE or USER_READ to access different endpoints, but I chose not to, an instead implemented it so that ADMIN and USER both can access the /api/user endpoint, but still have different access to the different endpoints in the UserController.

Other than that I think I got everything working as it should, except I did not implement any sort of error-handling as it didn't say so in the assignment, and on top of that I didn't implement the logout feature.

Also in the back of my mind I remember in one lecture we were told to use templates in the exam, but the exam said not to use frontend so there is no implementation of templates.

There is also a bug that happens when you try to create a new user and if you create a user with the same username that is already in the database then some of the methods will not work. F.eks fetching the userinfo by username as it is a duplicate.
